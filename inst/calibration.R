#' Cluster calibration function.
#'
#' This function controls the entire calibration procedure in CascadeDashboard, and is a port of the
#' version used in the R-package
#'
#' @param country string defining country name
#'
#' @param data list of calibration-ready data, generated by GetMasterData()
#'
#' @param maxIterations maximum number of model simulations to be generated
#'
#' @param maxError maximum acceptable total simulation error
#'
#' @param limit minimum number of accepted parameter sets below maxError
#'
#' @param parRange vector containing cascade parameter range
#'
#' @param targetIterations target number of initial and sensical values that will be generated
#'
#' @export
RunClusterCalibration <- function(country, data, maxIterations, maxError, limit, parRange, targetIterations = 1e4) {
    # limit = 100
    # maxIterations = 1e4
    # maxError = 2

    # Set Global Variables
    time <- seq(0, 5, 1)
    p <- parameters(
        prop_preART_500    = data[["cd4"]][1,"prop.Off.ART.500"][[1]],
        prop_preART_350500 = data[["cd4"]][1,"prop.Off.ART.350500"][[1]],
        prop_preART_250350 = data[["cd4"]][1,"prop.Off.ART.250350"][[1]],
        prop_preART_200250 = data[["cd4"]][1,"prop.Off.ART.200250"][[1]],
        prop_preART_100200 = data[["cd4"]][1,"prop.Off.ART.100200"][[1]],
        prop_preART_50100  = data[["cd4"]][1,"prop.Off.ART.50100"][[1]],
        prop_preART_50     = data[["cd4"]][1,"prop.Off.ART.50"][[1]],
        t_1 = ConvertYear(data[["treatment_guidelines"]][["more500"]]),
        t_2 = ConvertYear(data[["treatment_guidelines"]][["less500"]]),
        t_3 = ConvertYear(data[["treatment_guidelines"]][["less350"]]),
        t_4 = ConvertYear(data[["treatment_guidelines"]][["less250"]]),
        t_5 = ConvertYear(data[["treatment_guidelines"]][["less200"]])
    )

    ## Sample Parameters
    # Defines max / min
    # Allows user to override these
    # Uses LHS to sample parameter space
    message("Defining parameter space")
    lhs <- FME::Latinhyper(parRange, num = targetIterations)

    ## Sample Initial Compartment Values
    # Define max / min (also accounts for missing data)
    # Uses LHS to sample parameter space
    # Fishes out only sensical data
    # Deletes previous data.frame


    # While loop setup, ensures we get 10k iterations to trial.
    # Can always be extended to KEEP GOING endlessly
    initRange <- DefineInitRange(data = data, min = 0.5, max = 1.5)
    its <- 0L
    lhsInitial_Out <- matrix()

    while (its < targetIterations) {
        lhsInitial <- FME::Latinhyper(initRange, num = maxIterations * 5)
        lhsInitial_Sense <- FindSense(samples = lhsInitial)
        if (is.na(lhsInitial_Out[[1]])) {
            lhsInitial_Out <- lhsInitial_Sense
        } else {
            lhsInitial_Out <- rbind(lhsInitial_Out, lhsInitial_Sense)
        }
        its <- dim(lhsInitial_Out)[1]
    }

    # Garbage collection
    rm(lhsInitial)
    rm(lhsInitial_Sense)

    ## Sample Incidence
    # Define max / min (from Spectrum Uncertainty Analysis)
    # Uses LHS to sample parameter space
    incRange <- DefineIncidenceRange(incidenceData = data$incidence)
    lhsIncidence <- FME::Latinhyper(incRange, num = targetIterations)

    ## For each draw, update parameter vector (p), run model, calculate error and store it.
    # Initial Calibration
    message("Running simulations")
    # pb <- txtProgressBar(min = 0, max = limit, style = 1)
    v <- 0
    selectedRuns <<- c()
    minError <<- 1e6
    minErrorRun <<- NULL
    runError <<- c()
    CalibOut <<- c()
    for (k in 1:dim(lhsInitial_Out)[1]) {

        p[["Rho"]]     <- lhs[,"rho"][k]
        p[["Epsilon"]] <- lhs[,"epsilon"][k]
        p[["Kappa"]]   <- lhs[,"kappa"][k]
        p[["Gamma"]]   <- lhs[,"gamma"][k]
        p[["Theta"]]   <- lhs[,"theta"][k]
        p[["Omega"]]   <- lhs[,"omega"][k]
        p[["p"]]       <- lhs[,"p"][k]
        p[["q"]]       <- lhs[,"q"][k]

        i <- incidence(as.double(lhsIncidence[k,]))
        y <- GetCalibInitial(p, data, init2010 = lhsInitial_Out[k,])
        iOut <- SSE(AssembleComparisonDataFrame(country = country, model = CallCalibModel(time, y, p, i), data = data))
        runError[k] <<- sum(iOut[iOut$source == "error", "value"])

        # If error <= maxError then store value of k
        if (runError[k] <= maxError & v < limit) {
            v <- v + 1
            if (runError[k] < minError) {
                minError <<- runError[k]
                minErrorRun <<- v
            }
            selectedRuns[v] <<- k
            CalibOut <<- rbind(CalibOut, iOut)
            message(paste(paste0(round((v / limit) * 100, digits = 0), "%"), "of", paste0(round((k / dim(lhsInitial_Out)[1]) * 100, digits = 0), "%")))
            # setTxtProgressBar(pb, v)
            if (v == limit) break;
        }
        if (k == dim(lhsInitial_Out)[1]) warning("Hit iteration wall.")
    }

    # Global Data Frames for Parameters / Initial Values
    CalibParamOut <<- FillParValues(samples = lhs,             positions = selectedRuns, limit = limit)
    CalibInitOut  <<- FillInitValues(samples = lhsInitial_Out, positions = selectedRuns, limit = limit)
    CalibIncOut   <<- FillIncValue(samples = lhsIncidence,     positions = selectedRuns, limit = limit)

    # Calculate min and max values used by parameter set (deprecated now?)
    ParamMaxMin <<- data.frame(
        min = apply(CalibParamOut, 2, min),
        max = apply(CalibParamOut, 2, max)
    )
    message(paste("\nminErrorRun =", minErrorRun))

    out <- list(
        CalibIncOut   = CalibIncOut,
        CalibInitOut  = CalibInitOut,
        CalibOut      = CalibOut,
        CalibParamOut = CalibParamOut,
        MasterData    = data,
        minError      = minError,
        minErrorRun   = minErrorRun,
        ParamMaxMin   = ParamMaxMin,
        runError      = runError,
        selectedRuns  = selectedRuns
    )
    out
}

#' Wrapper around enqueue object to pass calibration function directly to cluster
#'
#' @param countryName string defining country name
#'
#' @param MaxError maximum acceptable total simulation error
#'
#' @param MinNumber minimum number of accepted parameter sets below maxError
#'
#' @export
PushClusterCalibration <- function(countryName, MaxError, MinNumber) {
    # setup
    MasterData <- GetMasterDataSet(countryName)
    parRange <- DefineParmRange(p = c(0.7, 1), omega = c(0, 0.01))

    # pass to cluster
    t <- obj$enqueue(
        RunClusterCalibration(
            country = countryName,
            data = MasterData,
            maxIterations = 1e4,
            maxError = MaxError,
            limit = MinNumber,
            parRange = parRange,
            targetIterations = 1e5)
    )

    # print task_id
    message(paste("task_id:", t$id))

    # return t
    return(t)
}

#' Generate plots following calibration
#'
#' @param wd working directory
#'
#' @param countryName string defining country name
#'
#' @export
CalibrationPlots <- function(wd, countryName) {
    # create output directly
    out_dir <- paste0(wd,"/results/", tolower(countryName), "/cal/")
    system(paste0("mkdir -p ", out_dir))

    # figure font set
    figFont <<- "Avenir Next"

    # Cascade in 2015
    graphics.off(); quartz.options(w = 10, h = 4)
    fig1 <- BuildCalibPlot_Thesis(data = CalibOut,
        originalData = MasterData,
        limit = MinNumber)
    print(fig1)
    quartz.save(file = paste0(out_dir, "cascade-2015.pdf"), type = "pdf")

    # Error Histogram
    graphics.off(); quartz.options(w = 6, h = 3)
    fig2 <- BuildCalibrationHistogram_Thesis(
        runError = runError,
        maxError = 0.06)
    print(fig2)
    quartz.save(file = paste0(out_dir, "calib-hist.pdf"), type = "pdf")

    # Calibration Detail
    graphics.off(); quartz.options(w = 10, h = 8)
    fig3 <- BuildCalibDetailPlot_Thesis(
        data = CalibOut,
        originalData = MasterData,
        limit = MinNumber)
    print(fig3)
    quartz.save(file = paste0(out_dir, "calib-detail.pdf"), type = "pdf")

    # Parameter Histograms
    graphics.off(); quartz.options(w = 10, h = 4)
    fig4 <- BuildCalibrationParameterHistGroup_Thesis()
    print(fig4)
    quartz.save(file = paste0(out_dir, "par-hist.pdf"), type = "pdf")

    # DataReviewPlot
    graphics.off(); quartz.options(w = 10, h = 4)
    fig5 <- BuildDataReviewPlot_Thesis(data = MasterData$calib)
    print(fig5)
    quartz.save(file = paste0(out_dir, "calib-data.pdf"), type = "pdf")

    # Parameter values
    a <- paste0(round(Quantile_95(CalibParamOut[["rho"]])[["mean"]], 4),
        " [",
            round(Quantile_95(CalibParamOut[["rho"]])[["lower"]], 4),
        " to ",
            round(Quantile_95(CalibParamOut[["rho"]])[["upper"]], 4),
        "]")
    b <- paste0(round(Quantile_95(CalibParamOut[["q"]])[["mean"]], 4),
        " [",
            round(Quantile_95(CalibParamOut[["q"]])[["lower"]], 4),
        " to ",
            round(Quantile_95(CalibParamOut[["q"]])[["upper"]], 4),
        "]")
    c <- paste0(round(Quantile_95(CalibParamOut[["epsilon"]])[["mean"]], 4),
        " [",
            round(Quantile_95(CalibParamOut[["epsilon"]])[["lower"]], 4),
        " to ",
            round(Quantile_95(CalibParamOut[["epsilon"]])[["upper"]], 4),
        "]")
    d <- paste0(round(Quantile_95(CalibParamOut[["kappa"]])[["mean"]], 4),
        " [",
            round(Quantile_95(CalibParamOut[["kappa"]])[["lower"]], 4),
        " to ",
            round(Quantile_95(CalibParamOut[["kappa"]])[["upper"]], 4),
        "]")
    e <- paste0(round(Quantile_95(CalibParamOut[["gamma"]])[["mean"]], 4),
        " [",
            round(Quantile_95(CalibParamOut[["gamma"]])[["lower"]], 4),
        " to ",
            round(Quantile_95(CalibParamOut[["gamma"]])[["upper"]], 4),
        "]")
    f <- paste0(round(Quantile_95(CalibParamOut[["theta"]])[["mean"]], 4),
        " [",
            round(Quantile_95(CalibParamOut[["theta"]])[["lower"]], 4),
        " to ",
            round(Quantile_95(CalibParamOut[["theta"]])[["upper"]], 4),
        "]")
    g <- paste0(round(Quantile_95(CalibParamOut[["p"]])[["mean"]], 4),
        " [",
            round(Quantile_95(CalibParamOut[["p"]])[["lower"]], 4),
        " to ",
            round(Quantile_95(CalibParamOut[["p"]])[["upper"]], 4),
        "]")
    h <- paste0(round(Quantile_95(CalibParamOut[["omega"]])[["mean"]], 4),
        " [",
            round(Quantile_95(CalibParamOut[["omega"]])[["lower"]], 4),
        " to ",
            round(Quantile_95(CalibParamOut[["omega"]])[["upper"]], 4),
        "]")

    tabl <- list(a,b,c,d,e,f,g,h)
    names(tabl) <- c("rho", "q", "epsilon", "kappa", "gamma", "theta", "p", "omega")
    return(tabl)
}
