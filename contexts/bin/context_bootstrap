#!/usr/bin/env Rscript
# autogenerated by context; do not edit
local({
par <- new.env(parent=emptyenv())
context_log <- function (topic, value) 
{
    if (isTRUE(getOption("context.log"))) {
        n <- length(value) - 1L
        if (n > 0L) {
            topic <- c(topic, rep_len("...", n))
        }
        str <- trimws(sprintf("[ %-9s ]  %s", topic, value))
        if (n > 0L) {
            str <- paste(str, collapse = "\n")
        }
        message(str)
        if (!is.null(par$cl)) {
            parallel::clusterCall(par$cl, "message", str)
        }
    }
}
context_repos <- function (sources) 
{
    r <- getOption("repos")
    r <- r[r != sources$cran]
    r["CRAN"] <- sources$cran
    if (!is.null(sources$repos)) {
        r <- c(r, sources$repos)
    }
    if (!is.null(sources$local_drat)) {
        drat_add_empty_bin(contrib.url(sources$local_drat, "binary"))
        r <- c(r, local_drat = file_url(sources$local_drat))
    }
    r
}
drat_add_empty_bin <- function (path) 
{
    path_PACKAGES <- file.path(path, "PACKAGES")
    if (!file.exists(path_PACKAGES)) {
        dir.create(path, FALSE, TRUE)
        writeLines(character(0), path_PACKAGES)
    }
}
file_url <- function (path) 
{
    full_path <- normalizePath(path, winslash = "/")
    paste0("file://", if (substr(full_path, 1, 1) == "/") 
        ""
    else "/", full_path)
}
install_packages <- function (packages, sources = package_sources(), lib = NULL, 
    ..., error = TRUE, move_in_place = FALSE) 
{
    if (length(packages) == 0L) {
        return()
    }
    r <- context_repos(sources)
    context_log("install", paste(packages, collapse = ", "))
    if (is.null(lib)) {
        lib <- .libPaths()[[1]]
    }
    if (move_in_place) {
        lib_real <- lib
        pat <- sprintf("CONTEXT_%s_%d_TMP", Sys.info()[["nodename"]], 
            Sys.getpid())
        lib <- tempfile(pat, lib_real)
        dir.create(lib, FALSE)
        on.exit(unlink(lib, recursive = TRUE))
        context_log("tmplib", lib)
    }
    install.packages2(packages, repos = r, ..., lib = lib, error = error)
    if (move_in_place) {
        installed <- .packages(TRUE, lib)
        re <- "^CONTEXT_(.*)_TMP(.*)$"
        others <- setdiff(dir(lib_real, pattern = re), basename(lib))
        if (length(others) > 0L) {
            context_log("us", sub(re, "\\1", basename(lib)))
            context_log("others", paste(sub(re, "\\1", others), 
                collapse = ", "))
        }
        new <- setdiff(installed, dir(lib_real))
        exist <- setdiff(installed, new)
        file.copy(file.path(lib, installed), lib_real, overwrite = FALSE, 
            recursive = TRUE)
        msg <- c(if (length(new) > 0L) paste("copied", paste(new, 
            collapse = ", ")), if (length(exist) > 0L) paste("skipped", 
            paste(exist, collapse = ", ")))
        context_log("installed", paste(msg, collapse = " | "))
    }
    invisible()
}
install.packages2 <- function (pkgs, ..., error = TRUE) 
{
    e <- NULL
    capture <- function(e) {
        if (error) {
            catch <- grepl("package.*(is|are) not available", 
                e$message) || grepl("installation of package.*had non-zero exit status", 
                e$message)
            if (catch) {
                e <<- e
            }
        }
    }
    withCallingHandlers(install.packages(pkgs, ...), warning = capture)
    if (!is.null(e)) {
        stop(e$message, call. = FALSE)
    }
}
package_sources <- function (cran = NULL, repos = NULL, github = NULL, bitbucket = NULL, 
    local = NULL, expire = 1) 
{
    if (is.null(cran)) {
        cran <- "http://cran.rstudio.com"
    }
    if (!is.null(repos)) {
        names(repos) <- repos
        is_drat <- grepl("^drat://", repos)
        repos[is_drat] <- sprintf("https://%s.github.io/drat/", 
            sub("^drat://", "", repos[is_drat]))
        if (!all(grepl("^[a-z]+://", repos))) {
            stop("Missing url scheme")
        }
    }
    if (!is.null(github)) {
        github <- apply(parse_package_pointer(github), 1, as.list)
    }
    if (!is.null(bitbucket)) {
        bitbucket <- apply(parse_package_pointer(bitbucket), 
            1, as.list)
    }
    if (!is.null(local)) {
        if (!all(file.exists(local))) {
            stop("Missing local files")
        }
        f <- function(x) {
            list(str = x, path = normalizePath(x, mustWork = TRUE))
        }
        local <- setNames(lapply(local, f), local)
    }
    structure(list(cran = cran, repos = repos, github = github, 
        bitbucket = bitbucket, local = local, expire = as.difftime(1, 
            units = "days")), class = "package_sources")
}
parse_package_pointer <- function (x) 
{
    re <- "^([^/]+)/([^/@#[:space:]]+)(.*)$"
    if (!all(grepl(re, x))) {
        stop("Invalid package specification")
    }
    user <- sub(re, "\\1", x)
    repo <- sub(re, "\\2", x)
    rest <- sub(re, "\\3", x)
    re_subdir <- "^(/[^@#[:space:]]*)(.*)"
    i <- grepl(re_subdir, rest)
    subdir <- rep(NA_character_, length(x))
    subdir[i] <- sub("^/", "", sub(re_subdir, "\\1", rest[i]))
    rest[i] <- sub(re_subdir, "\\2", rest[i])
    re_ref <- "^(@[^#[:space:]]*)(.*)"
    i <- grepl(re_ref, rest)
    ref <- rep("master", length(x))
    ref[i] <- sub("^@", "", sub(re_ref, "\\1", rest[i]))
    rest[i] <- sub(re_ref, "\\2", rest[i])
    subdir[nchar(subdir) == 0L] <- NA_character_
    ref0 <- !nzchar(ref, FALSE)
    if (any(ref0)) {
        stop("Invalid reference: ", paste(x[ref0], collapse = ", "))
    }
    if (any(nzchar(trimws(rest)))) {
        stop("Invalid parse")
    }
    ret <- cbind(user = user, repo = repo, subdir = subdir, ref = ref, 
        str = x)
    rownames(ret) <- x
    ret
}
path_drat <- function (root) 
{
    file.path(root, "drat")
}
path_library <- function (root) 
{
    file.path(root, "R", R.version[["platform"]], r_version(3))
}
path_version <- function (root) 
{
    file.path(root, "context_version")
}
r_version <- function (n) 
{
    if (n < 0L || n > 3L) {
        stop("Invalid n")
    }
    getRversion()[1, seq_len(n)]
}
read_version <- function (root) 
{
    filename <- path_version(root)
    if (file.exists(filename)) {
        package_version(readLines(filename))
    }
    else {
        package_version("0.0")
    }
}
use_local_library <- function (lib) 
{
    context_log("lib", lib)
    dir.create(lib, FALSE, TRUE)
    .libPaths(union(lib, .libPaths()))
    invisible(lib)
}
bootstrap <- function (root) 
{
    options(context.log = TRUE)
    context_log("bootstrap", normalizePath(root))
    lib <- use_local_library(path_library(root))
    if ("context" %in% .packages(TRUE, lib)) {
        v_installed <- packageVersion("context", lib)
        v_needed <- read_version(root)
        if (v_installed >= v_needed) {
            context_log("ok", "")
            if (!isTRUE(v_installed >= v_needed)) {
                context_log("warn", "platform specific weirdness?")
            }
            return()
        }
        else {
            context_log("upgrade", sprintf("context: %s -> %s", 
                v_installed, v_needed))
        }
    }
    else {
        context_log("install", "context")
    }
    path_local_drat <- path_drat(root)
    context_local <- length(dir(file.path(path_local_drat, "src/contrib"), 
        "^context_.*\\.tar\\.gz")) > 0L
    package_sources <- list(cran = "http://cran.rstudio.com")
    if (context_local) {
        package_sources$local_drat <- path_local_drat
    }
    else {
        package_sources$repos <- "https://richfitz.github.io/drat/"
    }
    install_packages("context", lib = lib, sources = package_sources, 
        error = TRUE, move_in_place = TRUE)
    context_log("done", "")
}
main <- function () 
{
    if (exists("CONTEXT_ROOT")) {
        root <- get("CONTEXT_ROOT")
    }
    else {
        args <- commandArgs(TRUE)
        if (length(args) != 1L) {
            stop("Usage: context_bootstrap <root>")
        }
        root <- args[[1]]
    }
    bootstrap(root)
}
main()
})
